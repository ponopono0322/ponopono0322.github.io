---
title:  "알고리즘 개인 정리"
excerpt: "핵심 포인트만 짚어가기"

categories:
  - Algorithm
tags:
  - [Algorithm, DP, Array, List, Stack, BFS, DP]

toc: true
toc_sticky: true
 
date: 2022-01-12
last_modified_at: 2022-01-12
---

## DP
### [프로그래머스]N으로 표현
목표: 같은 수를 최소 사용으로 정답을 만들어라.
```
// 예시
12 = 5 + 5 + (5/5) + (5/5)  (6개)
12 = 55/5 + 5/5             (5개)
12 = (55 + 5)/5             (4개)
```

```
// 해석
숫자 5를 1번 사용해서 만들 수 있는 수:
5
숫자 5를 2번 사용해서 만들 수 있는 수:
55, 5+5, 5-5, 5*5, 5/5
숫자 5를 3번 사용해서 만들 수 있는 수:
555,
55+5, 55-5, 55*5, 55/5,
(5+5)+5, (5+5)-5, (5+5)*5, (5+5)/5,
(5-5)+5, (5-5)-5, (5-5)*5, (5-5)/5,
(5*5)+5, (5*5)-5, (5*5)*5, (5*5)/5,
(5/5)+5, (5/5)-5, (5/5)*5, (5/5)/5
```

풀이법: *이전까지의 결과에 사칙연산을 한 결과를 더함*

## 배열
### [1475] 방 번호
목표: 한 세트에 0~9까지 적힌 숫자들을 조합해 요구하는 수를 최소 세트로 구성하라.
```
// 예시
9999  -> 2
122   -> 2
12635 -> 1
888888-> 6
```

```
// 해석
[0] * 10 배열에 입력받은 string을 하나씩 순회하며 카운팅.
6과 9의 등장 수를 동일하게 보기 위해 (6의 개수 == 9의 개수)일 땐 6을,
(6의 개수 != 9의 개수)일 땐 9를 증가시키는 구조로 설계함.
이후 배열중 최대값 max를 써서 결과도출
```

### [3273] 두 수의 합
목표: 입력값들중 두 개의 숫자를 더해 요구하는 숫자를 만들 수 있는 조합수를 구하라.

```
// 예시
배열/원하는 숫자 -> 정답
[5, 12, 7, 10, 9, 1, 2, 3, 11], 13  ->  3
```

```
// 해석
이중 반복문으로 구할 수 있으나 반복할 수가 매우 크므로 시간초과.
-> 투포인터 방법
좌->우(i), 우-> 좌(j)로 각각 가는 인덱스가 있음.
두 수의 합 > 요구하는 숫자 => j++
두 수의 합 = 요구하는 숫자 => counter, i++
두 수의 합 < 요구하는 숫자 => i++
```

### [1919] 애너그램 만들기
목표: 두 단어를 공통되게 하는 최소 제거 알파벳 수를 구하라.
```
// 예시
bared, dared => 2
aabbcc, xxyybb => 8
```

```
// 해석
공통인 부분을 Counter를 사용해 사전형태로 구해서 차집합을 구한다.
sum((Counter(x)-Counter(y)).values())
```

## 리스트
### [5397] 키로커
목표: 조건에 맞게 비밀번호(문자열)를 구하라
```
// 예시
<<BP<A>>Cd-   =>    BAPC
ThIsIsS3Cr3t  =>    ThIsIsS3Cr3t
```

```
// 해석
키보드 방향키 입력값 <>을 기준으로 각각 배열(left, right)을 만들어서 저장, 출력

>일 때 right 배열에 값이 있다면 pop 및 left append,
<일 때 left 배열에 값이 있다면 pop 및 right append,
-일 때 left 배열 pop
==> left는 그대로, right는 reverse해서 join
```

### [1158] 요세푸스 문제
목표: N까지의 배열에서 K*번째 인덱스를 빼라.
```
// 예시
7, 3  => <3, 6, 2, 7, 5, 1, 4>
```

```
// 해석
한 차례 인덱스를 삭제하고 나면, 그 위치가 유지된다.
만약 3번째 인덱스를 삭제했다면, 다음 삭제 위치는 6이다.

이 문제에서의 핵심은 인덱스 % (출력하려는 배열 길이). 나머지를 구하는 것이다.

if idx >= len(arr):
    idx = idx%len(arr)

그런다음 <,>을 배열과 join 해서 출력
```

## 스택
### [10773] 제로
목표: 입력조건에 맞게 명령을 수행하라.
```
// 예시
4 3 0 4 0 => 0
10  1 3 5 4 0 0 7 0 0 6 =>  7
```

```
// 해석
0이면 앞의 요소를 삭제
최종 결과를 합산

파이썬은 장점을 이용하여 리스트로 가볍게 append, pop, sum으로 해결
n = input()
if n:
  append(n)
else:
  pop()
```

### [1874] 스택 수열
목표: N까지의 스텍으로 쌓은 배열을 이용하여 입력된 배열을 만들어라.
```
// 예시
8
4 3 6 8 7 5 2 1 -> +++--++-++-----
```

```
// 해석
1
12
123
1234
123
12
125
1256
이런식으로 진행된다는 말.(문제 해석이 어려웠다)
마지막으로 넣은 숫자를 저장하는 변수를 통해 push pop을 하면 된다
```

### [2493] 탑
목표: 수신을 받은 탑의 번호를 출력하라.

```
// 예시
5
6 9 5 7 4 =>  0 0 2 2 4
```

```
// 해석
수신을 시작한 부분의 인덱스를 가진 변수를 통해 pop push를 진행함

스텍 문제에서 자주 등장하는 구조로
for i in range(len(array))):
    while stack and array[stack[-1]] < array[i]:
        stack.pop()
    stack.append(i)
를 활용하여 푼다.
```

### [17298] 오큰수
목표: 자기 자신보다 큰 수가 있으면 그 수를, 큰 수가 없다면 -1을 출력

```
// 예시
4
3 5 2 7 =>  5 7 7 -1

4
9 5 4 8 =>  -1 8 8 -1
```

```
// 해석
자기 자신보다 큰 숫자가 있을 때까지 push 했다가, pop을 진행함

이때 배열 크기만큼 -1로 채운 배열에 인덱스 기준으로 큰 수를 넣어줌
arr[stack.pop()] = origin[i]
```

### [10799] 쇠막대기
목표: 명령어에 맞게 최종 분리된 막대기의 갯수를 구하라
```
// 예시
()(((()())(())()))(()) -> 17
(((()(()()))(())()))(()()) -> 24
```

```
// 해석
스텍이 쌓일 때(쇠막대기 갯수)마다 len(stack)을 해주는 것이다.
answer = 0
answer += len(st) (if '(' )
answer += 1       (else)

추가로 for i in arr으로 했을 때는 결과가 제대로 안 나온다!
stack[-1]보다 arr[i-1]으로 해야 결과가 제대로 나온다
```

### [2504] 괄호의 값
목표: 명령어에 맞게 계산하라
```
// 예시
(()[[]])([]) -> 28

[][]((]) -> 0
```

```
// 해석
() 단독으로 나온 경우 -> 2
[] 단독으로 나온 경우 -> 3
()안에 다른 것이 있을 경우 -> x2
[]안에 다른 것이 있을 경우 -> x3

모든 것을 곱셈으로 정의 할 예정이므로 1을 고정으로 갖는 변수 생성:(1)
if - else문으로 ()[] 구분후 (1)에 2또는 3을 곱함:(2)
정답에 (2)를 더한후:(3)
스텍에서 pop, (2)를 (1)로 초기화:(4)
만약 위의 로직에 없는 행위가 있을 경우 정답 0:(5)
```


## 덱

### [1021] 회전하는 큐
목표: N까지의 큐에서 조건에 맞게 꺼냈을 때의 반복횟수를 구하라

```
// 예시
10 3
1 2 3 -> 0

10 3
2 9 5 -> 8

32 6
27 16 30 11 6 23 -> 59

10 10
1 6 3 2 7 9 8 4 10 5 -> 14
```

```
// 해석
뽑으려는 위치가 총 길이의 절반 이하인지, 초과인지 구분한다음
앞에서 시작 혹은 뒤로 시작하도록 하고, 이동할 때마다 카운트 해주면 된다

deque.index(찾으려는 값) => 인덱스 번호를 바로 알 수 있다
```

### [5430] AC
목표: 명령어에 따라 결과를 출력하라

```
// 예시
4
RDD
[1,2,3,4] -> [2,1]

1
DD
[42] -> error
```

```
// 해석
배열에서 R인 경우에는 배열 뒤집기, D인 경우에는 앞부분 원소 빼기

해당 문제의 경우 R을 나온 수만큼 반복하면 시간 초과가 되기 때문에 R이 나온 횟수를 저장하고
짝수의 경우와 홀수인 경우를 나눠(짝수는 앞쪽, 홀수는 뒷쪽제거) 뒤집기 연산을 최소화 한다.
```

## BFS
### [1926] 그림
목표: 가장 큰 넓이를 구하라
```
// 예시
6 5
1 1 0 1 1
0 1 1 0 0
0 0 0 0 0
1 0 1 1 1
0 0 1 1 1
0 0 1 1 1

// 정답
4
9
```

```
// 해석
BFS에서 가장 큰 골조: 내 주위를 탐색
dx, dy = [-1,1,0,1], [0,0,-1,1] => 좌표

queue.append(x,y)
while queue:
    x, y = queue.popleft()

    for i in range(4):
        nx = x+dx
        ny = y+dy
        // 파이썬에서 이런 부등호가 가능하다
        if 0 <= nx < N and 0 <= ny < M: 
            // visited가 필요한 경우가 있고 아닌 경우도 있다
            if graph[nx][ny] == 1 and not visited[nx][ny]:
                visited[nx][ny] = True
                queue.append((nx, ny))


이후 graph[0][0]부터 탐색

본 문제에서는 가장 큰 영역을 찾는 것과 영역 갯수도 구해야하므로

if graph[i][j] == 1 and not visited[i][j]:
    cnt += 1 // 영역 갯수
    count = max(count, bfs(i, j)) // 가장 큰 영역
```

### [7576] 토마토
목표: 상자안에 모든 토마토가 익었다면 익기까지 걸린 시간을(이미 익었다면 0), 그렇지 못한다면 -1을 출력하라.

```
// 예시 1
6 4
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 1

// 예시 2
6 4
0 -1 0 0 0 0
-1 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 1

// 정답 1
8

// 정답 2
-1
```

```
// 해석
익은 토마토(1)의 위치가 queue로 들어가야 한다.
해당 문제는 1의 위치를 먼저 찾고 -> 그 위치를 큐에 넣은 다음->
그 큐를 순회하면서 0을 1로 바꾼다.

이때 깊이(날짜)를 1씩 추가해서 마지막에 추가된 값이 최종 걸린 일 수다.

결과를 구할 땐 ans = max(ans, max(i))으로 이중 반복문(2차원 배열)에서

각 행의 최대값을 저장..
```

### [4179] 불!
목표: 불을 피해 가장자리로 이동할 수 있으면 최단 경로를, 할 수 없을 땐 IMPOSSIBLE을 출력

```
// 예시
4 4
####
#JF#
#..#
#..#

// 정답
3
```

```
// 해석
불의 이동과 사람의 이동을 동시에 진행해야 한다.

필요한 배열:
1. 불과 사람의 방문 배열
2. 불과 사람의 이동 큐

불의 이동은 벽(#)이 아닌 경우만 체크하면 되지만,
if 0 <= nx < R and 0 <= ny < C:
    if not f_visited[nx][ny] and graph[nx][ny] != '#':
        f_visited[nx][ny] = f_visited[x][y] + 1
        f_queue.append((nx, ny))

사람의 이동은 벽을 체크한 이후, 불이 먼저 도달하지 않았음을 확인한다.

if 0 <= nx < R and 0 <= ny < C:
    if not j_visited[nx][ny] and graph[nx][ny] != '#':
        if not f_visited[nx][ny] or f_visited[nx][ny] > j_visited[x][y] + 1:
            j_visited[nx][ny] = j_visited[x][y] + 1
            j_queue.append((nx, ny))

만약 끝까지 다 돌았다면 가장자리에 도달한 것이다.
이동횟수가 담긴 결과를 출력하고

else:
    return j_visited[x][y] + 1

여기서 return하지 못했다면 함수 마지막에서 불가능함을 돌려준다.

return 'IMPOSSIBLE'
```

### [1697] 숨바꼭질
목표: 정해진 조건(x-1, x+1, x*2)에 따라 최단으로 움직여라

```
// 예시
5 17 => 4
5에서 출발, 17에 도착
```

```
// 해석
보통 움직일 수 있는 좌표를 아래와 같이 미리 설정하고 하는데,
dx = [-1,1,0,0]
dy = [0,0,-1,1]

본 문제에서는 유동적으로 계산하기 때문에 아래와 같이 하는 대신,
for i in range(4):

아래와 같이 바꿔준다.
for nx in [x-1, x+1, x*2]:

때문에 연산을 수행하는 과정도 아래와 같이 한다.

if 0<=nx<=max_n and Narr[nx] == 0:
    Narr[nx] = Narr[x]+1
    que.append(nx)
if nx == K:
    return Narr[nx]
```

### [7569] 토마토
목표: 토마토가 다 익는데 걸리는 시간을 구하라

```
// 예시 1
5 3 1
0 -1 0 0 0
-1 -1 0 1 1
0 0 0 1 1

// 예시 2
5 3 2
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 1 0 0
0 0 0 0 0

// 예시 3
4 3 2
1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1
-1 -1 -1 -1
1 1 1 -1

// 정답 1,2,3(순서대로)
-1
4
0
```

```
// 해석
앞선 1697번에서는 1차원으로 해결했다면, 이 문제는 3차원에서 수행한다.

따라서 순회할 배열은 다음과 같다.
dx = [-1,1,0,0,0,0]
dy = [0,0,1,-1,0,0]
dz = [0,0,0,0,1,-1]

이후 순회조건에 따라 순회한 후
if 0<=nx<h and 0<=ny<n and 0<=nz<m and array[nx][ny][nz]==0:
    array.append([nx,ny,nz])
    array[nx][ny][nz] = array[x][y][z]+1

문제에서 요구하는 조건에 따라 출력한다.
for i in graph:
    for j in i:
        if 0 in j:
            print(-1)
            exit(0)
        else:
            day = max(day,max(j))
print(day-1)
```

### [5427] 불
목표: 불이 번지기 전에 탈출하라

```
// 예시
1
4 3
####
#*@.
####

// 정답
2
```

```python
# 해석
'''방문하는 배열을 하나만 생성하고, 불의 이동을 가리키는 문구를 삽입한다
이후 순회할때 방문한 적이 없으면서 이동 가능한 구역을 찾아 불의 이동일지 사람의 이동일지 확인한다'''

# 현재 자리가 불인지 확인하는 것
if visited[x][y] != "FIRE":
    flag = visited[x][y]
else:
    flag = "FIRE"

# 순회할 때 불의 이동인지 사람의 이동인지 판단
if 0 <= nx < h and 0 <= ny < w:
    if visited[nx][ny] == -1 and
        (board[nx][ny] == "." or board[nx][ny] == "@"):
        if flag == "FIRE":
            visited[nx][ny] = flag
        else:
            visited[nx][ny] = flag + 1
        q.append((nx, ny))

# 결과를 반환하는 부분은 과거 풀이와 동일
else:
    if flag != "FIRE":
        return flag + 1

return "IMPOSSIBLE"
```

## 재귀

### [1629] 곱셈
목표: 자연수 A를 B번 곱한다음 C로 나눈 나머지를 구하라

```
// 예시
10 11 12 => 4
(10^11)%12 = 4
```

```python
# 해석
'''숫자가 매우 커지므로 나눠서 계산해야 한다.
지수법칙: A^(m+n) = A^m + A^n 
지수법칙을 응용해서 절반씩 나눠 재귀함수에 넣는다
'''

# 종료지점 설정
if n == 1:
    return a%C

# 반복구간 설정
tmp = multi(a,n//2)

# 계산구간 설정
if n%2:
    return (tmp*tmp*a) % C
else:
    return (tmp*tmp) % C

# 정답출력
print(multi(A,B))
```

### [1074] Z
목표: 주어진 좌표를 z모양으로 탐색하라

```
// 예시
2 3 1   =>  11
3 7 7   =>  63
1 0 0   =>  0
4 7 7   =>  63
10 511 511  =>  262143
10 512 512  =>  786432
```

```python
# 해석
'''
z 순회 단위가 2씩 커지므로 크기를 2, 4, 8.. 즉 2^N으로 잡는다.
N을 재귀로 넣어 위치 상황에 따라 연산을 하도록 한다
'''

# 종료지점 설정
if(N==0):
    return 0

# 사분면 구간 설정
half = 2**(N-1)

# 위치에 따른 계산식
if(r < half and c < half):
    return re(N-1, r, c)
if(r < half and c >= half):
    return half*half + re(N-1, r, c-half)
if(r >= half and c < half):
    return 2*half*half + re(N-1, r-half, c)

return 3*half*half + re(N-1, r-half, c-half)

# 결과 출력
print(re(N,r,c))
```

### [1780] 종이의 개수
목표: 각 영역으로 나뉜 구역의 개수를 구하라

```
// 예시
9
0 0 0 1 1 1 -1 -1 -1
0 0 0 1 1 1 -1 -1 -1
0 0 0 1 1 1 -1 -1 -1
1 1 1 0 0 0 0 0 0
1 1 1 0 0 0 0 0 0
1 1 1 0 0 0 0 0 0
0 1 -1 0 1 -1 0 1 -1
0 -1 1 0 1 -1 0 1 -1
0 1 -1 1 0 -1 0 1 -1

// 정답
10
12
11
```

```python
# 해석
'''
각 종이가 같은 수로 이뤄졌는지 파악
-> 아닐경우 3^2(9)로 나눈 후 다시 각 종이 계산
-> 각 영역별로 합산
'''

# 해당 위치의 수 파악
num_check = paper[x][y]

# 종이 영역을 탐색
for i in range(x, x + n):
    for j in range(y, y + n):

# 일치여부 검사(아닌경우)
if(paper[i][j] != num_check):

# 아닌경우 조각낸 영역을 재 탐색
for k in range(3):
    for l in range(3):
        clip(x + k * n//3, y + l * n//3, n//3)
return

# 일치여부 검사(맞는경우)
if(num_check == -1):
    a += 1
elif(num_check == 0):
    b += 1
else:
    c += 1

# 탐색
clip(0, 0, N)

# 결과출력
print(a)
print(b)
print(c)
```

### [2630] 색종이 만들기
목표: 나눠진 영역의 갯수를 구하라

```
// 예시
8
1 1 0 0 0 0 1 1
1 1 0 0 0 0 1 1
0 0 0 0 1 1 0 0
0 0 0 0 1 1 0 0
1 0 0 0 1 1 1 1
0 1 0 0 1 1 1 1
0 0 1 1 1 1 1 1
0 0 1 1 1 1 1 1

// 정답
9
7
```

```python
# 1780과 같은 풀이

# 나눠야하는 부분이 0과 1이므로 2로 나눈다
for k in range(2):
    for l in range(2):
        clip_paper(x + k * n//2, y + l * n//2, n//2)
```

### [1992] 쿼드트리
목표: 구역에 의해 문자열을 압축하라.
```
// 예시
8
11110000
11110000
00011100
00011100
11110000
11110000
11110011
11110011

// 정답
((110(0101))(0010)1(0001))
```

```python
# 해석
'''
왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래 4구역을 도는 동안 같은 숫자로 이뤄졌다면 그 숫자로,
그렇지 못하다면 영역을 한번 더 4분할로 쪼개 앞의 행위를 진행한다.
'''

# 해당 자리의 숫자 저장
check = graph[x][y]

# 영역 탐색
for i in range(x, x + n):
    for j in range(y, y + n):

# 조건분할(이상하게 n//2 적용이 안되서 다른 방식을 채택)
if check != graph[i][j]:
    check = -1
    break

# 재귀 및 출력
if check == -1:
    print("(", end='')
    n = n // 2
    dnc(x, y, n)
    dnc(x, y + n, n)
    dnc(x + n, y, n)
    dnc(x + n, y + n, n)
    print(")", end='')

# 다른 조건일 때의 출력
elif check == 1:
    print(1, end='')
else:
    print(0, end='')
```

## 백트래킹
### [15649] [15650] [15651] N과 M
목표: 조건에 맞게 수열을 출력하라
```
// 예시
[15649]     [15650]     [15651]
4 2         4 2         4 2

// 정답
[15649]     [15650]     [15651]
1 2         1 2         1 1
1 3         1 3         1 2
1 4         1 4         1 3
2 1         2 3         1 4
2 3         2 4         2 1
2 4         3 4         2 2
3 1                     2 3
3 2                     2 4
3 4                     3 1
4 1                     3 2
4 2                     3 3
4 3                     3 4
                        4 1
                        4 2
                        4 3
                        4 4
```

```python
# dfs 사용해서 푸는 것이 맞지만..
'''
파이썬 itertools 패키지에서 순열관련 함수를 제공하기 때문에
product, combinations, permutations을 사용하여 풀었다
'''

# 공통부분
from itertools import product, combinations, permutations

# 배열 생성(combinations, permutations)
arr = [i for i in range(1, N+1)]
# 배열 생성(product)
arr = []
for i in range(M):
    tmp =""
    for j in range(1, N+1):
        tmp+=str(j)
    arr.append(tmp)

# 결과 출력
for x in combinations(arr, M): # (combinations, permutations)
    print(*x) 

# 결과 출력
for x in product(*arr):
    print(*x)
```

### [15652] N과 M
목표: 조건에 맞게 수열을 출력하라
```
// 예시
4 2

// 정답
1 1
1 2
1 3
1 4
2 2
2 3
2 4
3 3
3 4
4 4
```

```python
# dfs를 이용한 재귀로 풀었다

# 재귀를 끝낼 부분
if len(s)==m:
    print(' '.join(map(str,s)))
    return

# 반복하는 부분
for i in range(start, n+1):
    s.append(i)
    dfs(i)
    s.pop()
    
```

### [6603] 로또
목표: 입력받은 숫자 배열중 6개를 뽑아 중복되지 않는 조합을 구하라

```
// 예시(정답은 매우 길어서 생략)
7 1 2 3 4 5 6 7
8 1 2 3 5 8 13 21 34
0 (0을 받으면 종료)

```

```python
# combinations를 사용해서 가볍게 푼다

# 배열을 받고
arr = list(map(int, input().split()[1:]))

# 출력
for i in combinations(arr, 6):
    print(*i)
```

## DP

### [1932] 정수 삼각형
목표: 정해진 조건(대각선 좌,우 아래)에 의한 최대값을 구하라

```
// 예시
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5   => 30
```

```python
# 해석: 이전 결과중 최대를 갖으면서 조건에 맞게 순회하는 방식

# 1번째는 1개이므로 생략, 2번째부터 순회
k = 2
for j in range(k):
    if j == 0:
        t[i][j] = t[i][j] + t[i - 1][j]
    elif i == j:
        t[i][j] = t[i][j] + t[i - 1][j - 1]
    else:
        t[i][j] = max(t[i - 1][j - 1], t[i - 1][j]) + t[i][j]
k += 1  # 피라미드 구조라 매 루프마다 순회량을 증가시키는 것이 핵심
```

### [11727] 2xn 타일링 2
목표: 가능한 경우의 수를 모두 구하라
```
// 예시
2   =>  3
8   =>  171
12  =>  2731
```

```python
# 해석
'''
일정한 규칙에 따라 경우의 수가 수식으로 결정될 수 있다.
1칸인 경우 => 1
2칸인 경우 => 3
3칸인 경우 => 5
4칸인 경우 => 11..
공식: n-1+(n-2)*2
'''
# 따라서 반목문을 통해 결과를 배열에 추가함
s = [0, 1, 3]
for i in range(3, 1001):
  s.append((s[i - 2] * 2) + s[i - 1])
```

### [2193] 이친수
목표: 1이 연속으로 나오지 않게 만들 수 있는 이진수 총 수를 구하라
```
// 예시
3   =>  2   // 100, 101

``` 

```python
# 해석
'''
일정한 규칙에 따라 경우의 수가 수식으로 결정될 수 있다.
1자리인 경우 => 1
2자리인 경우 => 1
3자리인 경우 => 2
4자리인 경우 => 3
5자리인 경우 => 5..
공식 n-2 + n-1
'''
s = [0]*n
# 1인 경우는 그냥 빼기
if n==1:
    print(1)
# 1이 아닌 경우
else:
    s[0], s[1] = 1, 1
    for i in range(2, n):
        s[i] = s[i-2] + s[i-1] # 핵심
    print(s[-1])
```

### [1912] 연속합

목표: 배열 내에서 연속된 수를 합하여 나올 수 있는 최대값을 구하라.

```
// 예시
10
10 -4 3 1 5 6 -35 12 21 -1  => 33

10
2 1 -4 3 4 -4 6 5 -5 1  =>  14

5
-1 -2 -3 -4 -5  => -1
```

```python
# 해석
'''
원 배열과 최대값을 저장한 배열과 비교하여 데이터를 저장해나간다.
두 수를 합한게(arr[i]+a[i+1]) 원 배열 앞 수(a[i+1)보다 작다면,
앞 수를 사용하는 것이 나으므로 갱신한다.
따라서
최대값을 저장하는 배열(arr[i]) + 원 배열 한 자리 앞 수(a[i+1])
    < 원 배열 한 자리 앞 수(a[i+1])
이라면 갱신하도록 설계한다.
'''
arr = [a[0]]
for i in range(n-1):
    arr.append(max(arr[i]+a[i+1], a[i+1]))
print(max(arr))
```