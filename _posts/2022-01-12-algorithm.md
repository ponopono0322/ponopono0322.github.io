---
title:  "알고리즘 개인 정리"
excerpt: "핵심 포인트만 짚어가기"

categories:
  - Algorithm
tags:
  - [Algorithm, DP, Array, List, Stack, BFS]

toc: true
toc_sticky: true
 
date: 2022-01-12
last_modified_at: 2022-01-12
---

## DP
### [프로그래머스]N으로 표현
목표: 같은 수를 최소 사용으로 정답을 만들어라.
```
// 예시
12 = 5 + 5 + (5/5) + (5/5)  (6개)
12 = 55/5 + 5/5             (5개)
12 = (55 + 5)/5             (4개)
```

```
// 해석
숫자 5를 1번 사용해서 만들 수 있는 수:
5
숫자 5를 2번 사용해서 만들 수 있는 수:
55, 5+5, 5-5, 5*5, 5/5
숫자 5를 3번 사용해서 만들 수 있는 수:
555,
55+5, 55-5, 55*5, 55/5,
(5+5)+5, (5+5)-5, (5+5)*5, (5+5)/5,
(5-5)+5, (5-5)-5, (5-5)*5, (5-5)/5,
(5*5)+5, (5*5)-5, (5*5)*5, (5*5)/5,
(5/5)+5, (5/5)-5, (5/5)*5, (5/5)/5
```

풀이법: *이전까지의 결과에 사칙연산을 한 결과를 더함*

## 배열
### [1475] 방 번호
목표: 한 세트에 0~9까지 적힌 숫자들을 조합해 요구하는 수를 최소 세트로 구성하라.
```
// 예시
9999  -> 2
122   -> 2
12635 -> 1
888888-> 6
```

```
// 해석
[0] * 10 배열에 입력받은 string을 하나씩 순회하며 카운팅.
6과 9의 등장 수를 동일하게 보기 위해 (6의 개수 == 9의 개수)일 땐 6을,
(6의 개수 != 9의 개수)일 땐 9를 증가시키는 구조로 설계함.
이후 배열중 최대값 max를 써서 결과도출
```

### [3273] 두 수의 합
목표: 입력값들중 두 개의 숫자를 더해 요구하는 숫자를 만들 수 있는 조합수를 구하라.

```
// 예시
배열/원하는 숫자 -> 정답
[5, 12, 7, 10, 9, 1, 2, 3, 11], 13  ->  3
```

```
// 해석
이중 반복문으로 구할 수 있으나 반복할 수가 매우 크므로 시간초과.
-> 투포인터 방법
좌->우(i), 우-> 좌(j)로 각각 가는 인덱스가 있음.
두 수의 합 > 요구하는 숫자 => j++
두 수의 합 = 요구하는 숫자 => counter, i++
두 수의 합 < 요구하는 숫자 => i++
```

### [1919] 애너그램 만들기
목표: 두 단어를 공통되게 하는 최소 제거 알파벳 수를 구하라.
```
// 예시
bared, dared => 2
aabbcc, xxyybb => 8
```

```
// 해석
공통인 부분을 Counter를 사용해 사전형태로 구해서 차집합을 구한다.
sum((Counter(x)-Counter(y)).values())
```

## 리스트
### [5397] 키로커
목표: 조건에 맞게 비밀번호(문자열)를 구하라
```
// 예시
<<BP<A>>Cd-   =>    BAPC
ThIsIsS3Cr3t  =>    ThIsIsS3Cr3t
```

```
// 해석
키보드 방향키 입력값 <>을 기준으로 각각 배열(left, right)을 만들어서 저장, 출력

>일 때 right 배열에 값이 있다면 pop 및 left append,
<일 때 left 배열에 값이 있다면 pop 및 right append,
-일 때 left 배열 pop
==> left는 그대로, right는 reverse해서 join
```

### [1158] 요세푸스 문제
목표: N까지의 배열에서 K*번째 인덱스를 빼라.
```
// 예시
7, 3  => <3, 6, 2, 7, 5, 1, 4>
```

```
// 해석
한 차례 인덱스를 삭제하고 나면, 그 위치가 유지된다.
만약 3번째 인덱스를 삭제했다면, 다음 삭제 위치는 6이다.

이 문제에서의 핵심은 인덱스 % (출력하려는 배열 길이). 나머지를 구하는 것이다.

if idx >= len(arr):
    idx = idx%len(arr)

그런다음 <,>을 배열과 join 해서 출력
```

## 스택
### [10773] 제로
목표: 입력조건에 맞게 명령을 수행하라.
```
// 예시
4 3 0 4 0 => 0
10  1 3 5 4 0 0 7 0 0 6 =>  7
```

```
// 해석
0이면 앞의 요소를 삭제
최종 결과를 합산

파이썬은 장점을 이용하여 리스트로 가볍게 append, pop, sum으로 해결
n = input()
if n:
  append(n)
else:
  pop()
```

### [1874] 스택 수열
목표: N까지의 스텍으로 쌓은 배열을 이용하여 입력된 배열을 만들어라.
```
// 예시
8
4 3 6 8 7 5 2 1 -> +++--++-++-----
```

```
// 해석
1
12
123
1234
123
12
125
1256
이런식으로 진행된다는 말.(문제 해석이 어려웠다)
마지막으로 넣은 숫자를 저장하는 변수를 통해 push pop을 하면 된다
```

### [2493] 탑
목표: 수신을 받은 탑의 번호를 출력하라.

```
// 예시
5
6 9 5 7 4 =>  0 0 2 2 4
```

```
// 해석
수신을 시작한 부분의 인덱스를 가진 변수를 통해 pop push를 진행함

스텍 문제에서 자주 등장하는 구조로
for i in range(len(array))):
    while stack and array[stack[-1]] < array[i]:
        stack.pop()
    stack.append(i)
를 활용하여 푼다.

```

### [17298] 오큰수
목표: 자기 자신보다 큰 수가 있으면 그 수를, 큰 수가 없다면 -1을 출력

```
// 예시
4
3 5 2 7 =>  5 7 7 -1

4
9 5 4 8 =>  -1 8 8 -1
```

```
// 해석
자기 자신보다 큰 숫자가 있을 때까지 push 했다가, pop을 진행함

이때 배열 크기만큼 -1로 채운 배열에 인덱스 기준으로 큰 수를 넣어줌
arr[stack.pop()] = origin[i]
이런식으로
```

### [10799] 쇠막대기
목표: 명령어에 맞게 최종 분리된 막대기의 갯수를 구하라
```
// 예시
()(((()())(())()))(()) -> 17
(((()(()()))(())()))(()()) -> 24
```

```
// 해석
스텍이 쌓일 때(쇠막대기 갯수)마다 len(stack)을 해주는 것이다.
answer = 0
answer += len(st) (if '(' )
answer += 1       (else)

추가로 for i in arr으로 했을 때는 결과가 제대로 안 나온다!
stack[-1]보다 arr[i-1]으로 해야 결과가 제대로 나온다
```

### [2504] 괄호의 값
목표: 명령어에 맞게 계산하라
```
// 예시
(()[[]])([]) -> 28

[][]((]) -> 0
```

```
// 해석
() 단독으로 나온 경우 -> 2
[] 단독으로 나온 경우 -> 3
()안에 다른 것이 있을 경우 -> x2
[]안에 다른 것이 있을 경우 -> x3

모든 것을 곱셈으로 정의 할 예정이므로 1을 고정으로 갖는 변수 생성:(1)
if - else문으로 ()[] 구분후 (1)에 2또는 3을 곱함:(2)
정답에 (2)를 더한후:(3)
스텍에서 pop, (2)를 (1)로 초기화:(4)
만약 위의 로직에 없는 행위가 있을 경우 정답 0:(5)
```


## 덱

### [1021] 회전하는 큐
목표: N까지의 큐에서 조건에 맞게 꺼냈을 때의 반복횟수를 구하라

```
// 예시
10 3
1 2 3 -> 0

10 3
2 9 5 -> 8

32 6
27 16 30 11 6 23 -> 59

10 10
1 6 3 2 7 9 8 4 10 5 -> 14
```

```
// 해석
뽑으려는 위치가 총 길이의 절반 이하인지, 초과인지 구분한다음
앞에서 시작 혹은 뒤로 시작하도록 하고, 이동할 때마다 카운트 해주면 된다

deque.index(찾으려는 값) => 인덱스 번호를 바로 알 수 있다
```

### [5430] AC
목표: 명령어에 따라 결과를 출력하라

```
// 예시
4
RDD
[1,2,3,4] -> [2,1]

1
DD
[42] -> error
```

```
// 해석
배열에서 R인 경우에는 배열 뒤집기, D인 경우에는 앞부분 원소 빼기

해당 문제의 경우 R을 나온 수만큼 반복하면 시간 초과가 되기 때문에 R이 나온 횟수를 저장하고
짝수의 경우와 홀수인 경우를 나눠(짝수는 앞쪽, 홀수는 뒷쪽제거) 뒤집기 연산을 최소화 한다.

```

## BFS
### [1926] 그림
목표: 가장 큰 넓이를 구하라
```
// 예시
6 5
1 1 0 1 1
0 1 1 0 0
0 0 0 0 0
1 0 1 1 1
0 0 1 1 1
0 0 1 1 1

// 정답
4
9
```

```
// 해석
BFS에서 가장 큰 골조: 내 주위를 탐색
dx, dy = [-1,1,0,1], [0,0,-1,1] => 좌표

queue.append(x,y)
while queue:
    x, y = queue.popleft()

    for i in range(4):
        nx = x+dx
        ny = y+dy
        // 파이썬에서 이런 부등호가 가능하다
        if 0 <= nx < N and 0 <= ny < M: 
            // visited가 필요한 경우가 있고 아닌 경우도 있다
            if graph[nx][ny] == 1 and not visited[nx][ny]:
                visited[nx][ny] = True
                queue.append((nx, ny))


이후 graph[0][0]부터 탐색

본 문제에서는 가장 큰 영역을 찾는 것과 영역 갯수도 구해야하므로

if graph[i][j] == 1 and not visited[i][j]:
    cnt += 1 // 영역 갯수
    count = max(count, bfs(i, j)) // 가장 큰 영역
```

### [7576] 토마토
목표: 상자안에 모든 토마토가 익었다면 익기까지 걸린 시간을(이미 익었다면 0), 그렇지 못한다면 -1을 출력하라.

```
// 예시 1
6 4
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 1

// 예시 2
6 4
0 -1 0 0 0 0
-1 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 1

// 정답 1
8

// 정답 2
-1
```

```
// 해석
익은 토마토(1)의 위치가 queue로 들어가야 한다.
해당 문제는 1의 위치를 먼저 찾고 -> 그 위치를 큐에 넣은 다음->
그 큐를 순회하면서 0을 1로 바꾼다.

이때 깊이(날짜)를 1씩 추가해서 마지막에 추가된 값이 최종 걸린 일 수다.

결과를 구할 땐 ans = max(ans, max(i))으로 이중 반복문(2차원 배열)에서

각 행의 최대값을 저장..
```

### [4179] 불!
목표: 불을 피해 가장자리로 이동할 수 있으면 최단 경로를, 할 수 없을 땐 IMPOSSIBLE을 출력

```
// 예시
4 4
####
#JF#
#..#
#..#

// 정답
3
```

```
// 해석
불의 이동과 사람의 이동을 동시에 진행해야 한다.

필요한 배열:
1. 불과 사람의 방문 배열
2. 불과 사람의 이동 큐

불의 이동은 벽(#)이 아닌 경우만 체크하면 되지만,
if 0 <= nx < R and 0 <= ny < C:
    if not f_visited[nx][ny] and graph[nx][ny] != '#':
        f_visited[nx][ny] = f_visited[x][y] + 1
        f_queue.append((nx, ny))

사람의 이동은 벽을 체크한 이후, 불이 먼저 도달하지 않았음을 확인한다.

if 0 <= nx < R and 0 <= ny < C:
    if not j_visited[nx][ny] and graph[nx][ny] != '#':
        if not f_visited[nx][ny] or f_visited[nx][ny] > j_visited[x][y] + 1:    # important code
            j_visited[nx][ny] = j_visited[x][y] + 1
            j_queue.append((nx, ny))

만약 끝까지 다 돌았다면 가장자리에 도달한 것이다.
이동횟수가 담긴 결과를 출력하고

else:
    return j_visited[x][y] + 1

여기서 return하지 못했다면 함수 마지막에서 불가능함을 돌려준다.

return 'IMPOSSIBLE'
```

