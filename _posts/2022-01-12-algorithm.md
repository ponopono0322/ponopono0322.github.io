---
title:  "알고리즘 개인 정리"
excerpt: "핵심 포인트만 짚어가기"

categories:
  - Algorithm
tags:
  - [Algorithm, DP, Array, List, Stack]

toc: true
toc_sticky: true
 
date: 2022-01-12
last_modified_at: 2022-01-12
---

## DP
### [프로그래머스]N으로 표현
목표: 같은 수를 최소 사용으로 정답을 만들어라.
```
// 예시
12 = 5 + 5 + (5/5) + (5/5)  (6개)
12 = 55/5 + 5/5             (5개)
12 = (55 + 5)/5             (4개)
```

```
// 해석
숫자 5를 1번 사용해서 만들 수 있는 수:
5
숫자 5를 2번 사용해서 만들 수 있는 수:
55, 5+5, 5-5, 5*5, 5/5
숫자 5를 3번 사용해서 만들 수 있는 수:
555,
55+5, 55-5, 55*5, 55/5,
(5+5)+5, (5+5)-5, (5+5)*5, (5+5)/5,
(5-5)+5, (5-5)-5, (5-5)*5, (5-5)/5,
(5*5)+5, (5*5)-5, (5*5)*5, (5*5)/5,
(5/5)+5, (5/5)-5, (5/5)*5, (5/5)/5
```

풀이법: *이전까지의 결과에 사칙연산을 한 결과를 더함*

## 배열
### [1475] 방 번호
목표: 한 세트에 0~9까지 적힌 숫자들을 조합해 요구하는 수를 최소 세트로 구성하라.
```
// 예시
9999  -> 2
122   -> 2
12635 -> 1
888888-> 6
```

```
// 해석
[0] * 10 배열에 입력받은 string을 하나씩 순회하며 카운팅.
6과 9의 등장 수를 동일하게 보기 위해 (6의 개수 == 9의 개수)일 땐 6을,
(6의 개수 != 9의 개수)일 땐 9를 증가시키는 구조로 설계함.
이후 배열중 최대값 max를 써서 결과도출
```

### [3273] 두 수의 합
목표: 입력값들중 두 개의 숫자를 더해 요구하는 숫자를 만들 수 있는 조합수를 구하라.

```
// 예시
배열/원하는 숫자 -> 정답
[5, 12, 7, 10, 9, 1, 2, 3, 11], 13  ->  3
```

```
// 해석
이중 반복문으로 구할 수 있으나 반복할 수가 매우 크므로 시간초과.
-> 투포인터 방법
좌->우(i), 우-> 좌(j)로 각각 가는 인덱스가 있음.
두 수의 합 > 요구하는 숫자 => j++
두 수의 합 = 요구하는 숫자 => counter, i++
두 수의 합 < 요구하는 숫자 => i++
```

### [1919] 애너그램 만들기
목표: 두 단어를 공통되게 하는 최소 제거 알파벳 수를 구하라.
```
// 예시
bared, dared => 2
aabbcc, xxyybb => 8
```

```
// 해석
공통인 부분을 Counter를 사용해 사전형태로 구해서 차집합을 구한다.
sum((Counter(x)-Counter(y)).values())
```

## 리스트
### [5397] 키로커
목표: 조건에 맞게 비밀번호(문자열)를 구하라
```
// 예시
<<BP<A>>Cd-   =>    BAPC
ThIsIsS3Cr3t  =>    ThIsIsS3Cr3t
```

```
// 해석
키보드 방향키 입력값 <>을 기준으로 각각 배열(left, right)을 만들어서 저장, 출력

>일 때 right 배열에 값이 있다면 pop 및 left append,
<일 때 left 배열에 값이 있다면 pop 및 right append,
-일 때 left 배열 pop
==> left는 그대로, right는 reverse해서 join
```

### [1158] 요세푸스 문제
목표: N까지의 배열에서 K*번째 인덱스를 빼라.
```
// 예시
7, 3  => <3, 6, 2, 7, 5, 1, 4>
```

```
// 해석
한 차례 인덱스를 삭제하고 나면, 그 위치가 유지된다.
만약 3번째 인덱스를 삭제했다면, 다음 삭제 위치는 6이다.

이 문제에서의 핵심은 인덱스 % (출력하려는 배열 길이). 나머지를 구하는 것이다.

if idx >= len(arr):
    idx = idx%len(arr)

그런다음 <,>을 배열과 join 해서 출력
```

## 스택
### [10773] 제로
목표: 입력조건에 맞게 명령을 수행하라.
```
// 예시
4 3 0 4 0 => 0
10  1 3 5 4 0 0 7 0 0 6 =>  7
```

```
// 해석
0이면 앞의 요소를 삭제
최종 결과를 합산

파이썬은 장점을 이용하여 리스트로 가볍게 append, pop, sum으로 해결
n = input()
if n:
  append(n)
else:
  pop()
```

### [1874] 스택 수열
목표: N까지의 스텍으로 쌓은 배열을 이용하여 입력된 배열을 만들어라.
```
// 예시
8
4 3 6 8 7 5 2 1 -> +++--++-++-----
```

```
// 해석
1
12
123
1234
123
12
125
1256
이런식으로 진행된다는 말.(문제 해석이 어려웠다)
마지막으로 넣은 숫자를 저장하는 변수를 통해 push pop을 하면 된다
```

### [2493] 탑
목표: 수신을 받은 탑의 번호를 출력하라.

```
// 예시
5
6 9 5 7 4 =>  0 0 2 2 4
```

```
// 해석
수신을 시작한 부분의 인덱스를 가진 변수를 통해 pop push를 진행함

스텍 문제에서 자주 등장하는 구조로
for i in range(len(array))):
    while stack and array[stack[-1]] < array[i]:
        stack.pop()
    stack.append(i)
를 활용하여 푼다.

```

### [17298] 오큰수
목표: 자기 자신보다 큰 수가 있으면 그 수를, 큰 수가 없다면 -1을 출력

```
// 예시
4
3 5 2 7 =>  5 7 7 -1

4
9 5 4 8 =>  -1 8 8 -1
```

```
// 해석
자기 자신보다 큰 숫자가 있을 때까지 push 했다가, pop을 진행함

이때 배열 크기만큼 -1로 채운 배열에 인덱스 기준으로 큰 수를 넣어줌
arr[stack.pop()] = origin[i]
이런식으로
```

## 덱

### [1021] 회전하는 큐
목표: N까지의 큐에서 조건에 맞게 꺼냈을 때의 반복횟수를 구하라

```
// 예시
10 3
1 2 3 -> 0

10 3
2 9 5 -> 8

32 6
27 16 30 11 6 23 -> 59

10 10
1 6 3 2 7 9 8 4 10 5 -> 14
```

```
// 해석
뽑으려는 위치가 총 길이의 절반 이하인지, 초과인지 구분한다음
앞에서 시작 혹은 뒤로 시작하도록 하고, 이동할 때마다 카운트 해주면 된다

deque.index(찾으려는 값) => 인덱스 번호를 바로 알 수 있다
```

### [5430] AC
목표: 명령어에 따라 결과를 출력하라

```
// 예시
4
RDD
[1,2,3,4] -> [2,1]

1
DD
[42] -> error
```

```
// 해석
배열에서 R인 경우에는 배열 뒤집기, D인 경우에는 앞부분 원소 빼기

해당 문제의 경우 R을 나온 수만큼 반복하면 시간 초과가 되기 때문에 R이 나온 횟수를 저장하고
짝수의 경우와 홀수인 경우를 나눠(짝수는 앞쪽, 홀수는 뒷쪽제거) 뒤집기 연산을 최소화 한다.

```

